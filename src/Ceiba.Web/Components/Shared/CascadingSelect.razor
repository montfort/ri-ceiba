@using Ceiba.Shared.DTOs
@typeparam TValue

<div class="form-group @CssClass">
    @if (!string.IsNullOrEmpty(Label))
    {
        <label for="@Id" class="form-label">@Label @(Required ? "*" : "")</label>
    }

    <select id="@Id"
            class="form-select @(IsInvalid ? "is-invalid" : "")"
            value="@CurrentStringValue"
            @onchange="OnSelectionChanged"
            disabled="@(Disabled || IsLoading)"
            @attributes="AdditionalAttributes">
        @if (IsLoading)
        {
            <option value="">Cargando...</option>
        }
        else if (Items == null || !Items.Any())
        {
            <option value="">@EmptyMessage</option>
        }
        else
        {
            <option value="">@PlaceholderText</option>
            @foreach (var item in Items)
            {
                <option value="@item.Id" selected="@(item.Id == GetIntValue())">@item.Nombre</option>
            }
        }
    </select>

    @if (IsInvalid && !string.IsNullOrEmpty(ValidationMessage))
    {
        <div class="invalid-feedback">@ValidationMessage</div>
    }
</div>

@code {
    [Parameter] public string? Id { get; set; }
    [Parameter] public string? Label { get; set; }
    [Parameter] public TValue Value { get; set; } = default!;
    [Parameter] public EventCallback<TValue> ValueChanged { get; set; }
    [Parameter] public List<CatalogItemDto>? Items { get; set; }
    [Parameter] public bool Required { get; set; } = false;
    [Parameter] public bool Disabled { get; set; } = false;
    [Parameter] public bool IsLoading { get; set; } = false;
    [Parameter] public bool IsInvalid { get; set; } = false;
    [Parameter] public string ValidationMessage { get; set; } = string.Empty;
    [Parameter] public string PlaceholderText { get; set; } = "Seleccione una opci√≥n";
    [Parameter] public string EmptyMessage { get; set; } = "No hay opciones disponibles";
    [Parameter] public string CssClass { get; set; } = string.Empty;
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    private string CurrentStringValue => Value?.ToString() ?? "";

    private int GetIntValue()
    {
        if (Value is int intVal) return intVal;
        // Use EqualityComparer to handle both reference and value types correctly
        if (!EqualityComparer<TValue>.Default.Equals(Value, default) && int.TryParse(Value?.ToString(), out var parsed)) return parsed;
        return 0;
    }

    private async Task OnSelectionChanged(ChangeEventArgs e)
    {
        var stringValue = e.Value?.ToString() ?? "";

        TValue newValue;
        if (typeof(TValue) == typeof(int))
        {
            newValue = (TValue)(object)(int.TryParse(stringValue, out var intVal) ? intVal : 0);
        }
        else if (typeof(TValue) == typeof(int?))
        {
            newValue = string.IsNullOrEmpty(stringValue)
                ? default!
                : (TValue)(object)int.Parse(stringValue);
        }
        else
        {
            newValue = (TValue)(object)stringValue;
        }

        if (!EqualityComparer<TValue>.Default.Equals(newValue, Value))
        {
            Value = newValue;
            await ValueChanged.InvokeAsync(newValue);
        }
    }
}
